#define CHAZ_USE_SHORT_NAMES

#include "Charmonizer/Core.h"
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

char *compiler        = NULL;
char *constant_prefix = NULL;
char *macro_prefix    = NULL;
char *typedef_prefix  = NULL;
char *function_prefix = NULL;

char*
capture_output(char *source, size_t source_len, size_t *output_len) 
{
    char *captured_output = NULL;
    FILE *app_source_fh, *targ_fh, *garbage_fh;
    char  command[256];
    int   command_len = 0;
    int   successful;
    
    /* clear out previous versions and test to make sure removal worked */
    if ( !remove_and_verify(TRY_APP_PATH) ) 
        die("Failed to delete file '%s'", TRY_APP_PATH);
    if ( !remove_and_verify(TARGET_PATH) )
        die("Failed to delete file '%s'", TARGET_PATH);

    /* write the source file */
    app_source_fh = fopen(TRY_SOURCE_PATH, "w");
    if (app_source_fh == NULL)
        die("Error opening file '%s': %s", TRY_SOURCE_PATH, strerror(errno));
    fwrite(source, source_len, sizeof(char), app_source_fh);
    if (fclose(app_source_fh))
        die("Error closing file '%s': %s", TRY_SOURCE_PATH, strerror(errno));

    
    /* security note: snprintf isn't available, so we just have to make sure
     * that the compiler command is short enough at an earlier stage.
     */
    sprintf(command, "%s " TRY_SOURCE_PATH " -o " TRY_APP_PATH "\0", compiler);

    /* Compile the source.
     * Unfortunately there's no completely portable way to redirect stderr
     * yet be able to recover it later, so we're stuck seeing the
     * errors when something fails.
     */
    system(command);

    /* see if compilation was successful */
    garbage_fh = fopen(TRY_APP_PATH, "r");
    successful = garbage_fh != NULL;
    if (garbage_fh != NULL && fclose(garbage_fh)) 
        die("Error closing file '%s': %s", TRY_SOURCE_PATH, strerror(errno));

    /* if compilation was successful... */
    if (successful) {
        /* run the app */
        sprintf(command, "./" TRY_APP_PATH "\0");
        system(command);

        /* slurp the app's output and write it to our fh */
        captured_output = slurp_file(TARGET_PATH, output_len);
    }
    else {
        *output_len = 0;
    }

    /* clean up */
    remove(TRY_SOURCE_PATH);
    remove(TRY_APP_PATH);
    remove(TARGET_PATH);

    return captured_output;
}

char*
slurp_file(char *file_path, size_t *len_ptr) 
{
    FILE   *const file = fopen(file_path, "r");
    char   *contents;
    size_t  len;
    long    check_val;

    /* sanity check */
    if (file == NULL)
        die("Error opening file '%s': %s", file_path, strerror(errno));

    /* find length; return NULL if the file has a zero-length */
    len = flength(file);
    if (len == 0) {
        *len_ptr = 0;
        return NULL;
    }

    /* allocate memory and read the file */
    contents = (char*)malloc(len * sizeof(char));
    if (contents == NULL)
        die("Out of memory at %d, %s", __FILE__, __LINE__);
    check_val = fread(contents, sizeof(char), len, file);

    /* weak error check, because CRLF might result in fewer chars read */
    if (check_val <= 0)
        die("Tried to read %d characters of '%s', got %d", (int)len,
            file_path, check_val);

    /* set length pointer for benefit of caller */
    *len_ptr = check_val;

    /* clean up */
    if (fclose(file))
        die("Error closing file '%s': %s", file_path, strerror(errno));

    return contents;
}

long 
flength(FILE *f) 
{
    const long bookmark = ftell(f);
    long check_val;
    long len;

    /* seek to end of file and check length */
    check_val = fseek(f, 0, SEEK_END);
    if (check_val == -1)
        die("fseek error : %s\n", strerror(errno));
    len = ftell(f);
    if (len == -1)
        die("fseek error : %s\n", strerror(errno));

    /* return to where we were */
    check_val = fseek(f, bookmark, SEEK_SET);
    if (check_val == -1)
        die("fseek error : %s\n", strerror(errno));

    return len;
}

void 
die(char* format, ...) 
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    exit(1);
}

void 
warn(char* format, ...) 
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
}

int
remove_and_verify(char *file_path) 
{
    /* try to remove the file */
    remove(file_path);

    /* return what *might* be success or failure */
    return can_open_file(file_path) ? 0 : 1;
}

int
can_open_file(char *file_path) 
{
    FILE *garbage_fh;

    /* use fopen as a portable test for the existence of a file */
    garbage_fh = fopen(file_path, "r");
    if (garbage_fh == NULL) {
        return 0;
    }
    else {
        fclose(garbage_fh);
        return 1;
    }
}

/**
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

