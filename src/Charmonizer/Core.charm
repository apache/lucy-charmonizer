#define CHAZ_USE_SHORT_NAMES

#include "Charmonizer/Core.h"
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

static void
grow_command_buf(size_t len);

static chaz_bool_t 
compile_and_verify(const char *source_path, const char *object_path, 
                   const char *source, size_t source_len);

static void
clean_up_try();

char *cc_command      = NULL;
char *cc_flags        = NULL;
char *os_name         = NULL;
char *object_flag     = NULL;
char *include_flag    = NULL;
char *obj_ext         = NULL;
char *exe_ext         = NULL;

char *constant_prefix = NULL;
char *macro_prefix    = NULL;
char *typedef_prefix  = NULL;
char *function_prefix = NULL;

int   verbosity       = 1;
chaz_bool_t want_short_names = false;

static char *devnull = NULL;
static chaz_bool_t charm_run_available = false;
static char *command_buf = NULL;
static size_t command_buf_len = 0;
static char *local_command_start = NULL;

static void
grow_command_buf(size_t command_len)
{
    if (command_len > command_buf_len) {
        command_buf = realloc(command_buf, command_len);
        if (command_buf == NULL) 
            die("allocation of command_buf failed");
        command_buf_len = command_len;
    }
}

static char charm_h_code[] = METAQUOTE
    #ifndef CHARM_H
    #define CHARM_H 1

    #include <stdio.h>

    #define Charm_Setup \
        freopen("_charmonizer_target", "w", stdout)
    
    #endif
METAQUOTE;

void
write_charm_h()
{
    write_file("_charm.h", charm_h_code, strlen(charm_h_code));
}

static char charm_run_code_a[] = METAQUOTE
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stddef.h>
    int main(int argc, char **argv)
    {
        char *command;
        size_t command_len = 1; /* terminating null */
        int i;
        
        /* rebuild the command line args, minus the name of this utility */
        for (i = 1; i < argc; i++) {
            command_len += strlen(argv[i]) + 1;
        }
        command = (char*)calloc(command_len, sizeof(char));
        for (i = 1; i < argc; i++) {
            strcat( strcat(command, " "), argv[i] );
        }

        /* redirect stderr to /dev/null or equivalent */
        freopen( 
METAQUOTE;

static char charm_run_code_b[] = METAQUOTE
             , "w", stderr);

        /* run the commmand and return its value to the parent process */
        return system(command);
    }
METAQUOTE;

void
build_charm_run()
{
    size_t code_len = strlen(charm_run_code_a) + strlen(charm_run_code_b) +
        strlen(devnull) + 20;
    char *code = (char*)malloc(code_len);
    chaz_bool_t compile_succeeded = false;

    sprintf(code, "%s \"%s\" %s", charm_run_code_a, devnull,
        charm_run_code_b);

    compile_succeeded = compile_and_verify("_charm_run.c", "_charm_run", 
        code, strlen(code));
    if (!compile_succeeded)
        die("failed to compile _charm_run helper utility");

    remove("_charm_run.c");
    charm_run_available = true;
}

static char print_one_code[] = METAQUOTE
    #include <stdio.h>
    int main() {
        freopen("_charmonizer_target", "w", stdout);
        printf("1");
        return 0;
    }
METAQUOTE;

void
chaz_Core_probe_compiler_syntax()
{
    char *captured;
    size_t captured_len;

    if (verbosity) {
        printf("Testing compiler/shell syntax...\n");
    }

    if (strcmp(os_name, "mswin32") == 0) {
        local_command_start = strdup(".\\");
    }
    else {
        local_command_start = strdup("./");
    }

    captured = capture_output(print_one_code, strlen(print_one_code),
        &captured_len);

    if (captured == NULL) {
        die("Failed to compile test file");
    }

    free(captured);
}

void
chaz_Core_probe_devnull()
{
    char *const devnull_options[] = {
        "/dev/null", 
        "/dev/nul", 
        "nul", 
        NULL
    };
    int i;

    if (verbosity)
        printf("Trying to find a bit-bucket a la /dev/null...\n");

    for (i = 0; devnull_options[i] != NULL; i++) {
        FILE *const probe_fh = fopen(devnull_options[i], "w");
        if (probe_fh != NULL) {
            devnull = strdup(devnull_options[i]);
            fclose(probe_fh);
            return;
        }
    }
    die("Couldn't find anything like /dev/null");
}

char*
capture_output(char *source, size_t source_len, size_t *output_len) 
{
    char *captured_output = NULL;
    chaz_bool_t compile_succeeded;

    /* clear out previous versions and test to make sure removal worked */
    if ( !remove_and_verify(TRY_APP_PATH) ) 
        die("Failed to delete file '%s'", TRY_APP_PATH);
    if ( !remove_and_verify(TARGET_PATH) )
        die("Failed to delete file '%s'", TARGET_PATH);

    compile_succeeded = compile_and_verify(TRY_SOURCE_PATH, TRY_APP_PATH, 
        source, source_len);

    if (compile_succeeded) {
        /* run the app, slurp the output */
        grow_command_buf(strlen(local_command_start) + strlen(TRY_APP_PATH));
        sprintf(command_buf, "%s%s", local_command_start, TRY_APP_PATH);
        system(command_buf);
        captured_output = slurp_file(TARGET_PATH, output_len);
    }
    else {
        *output_len = 0;
    }

    clean_up_try();

    return captured_output;
}

static chaz_bool_t 
compile_and_verify(const char *source_path, const char *object_path, 
                   const char *source, size_t source_len)
{
    FILE *app_source_fh, *garbage_fh;
    int   successful;
    
    /* write the source file */
    write_file(source_path, source, source_len);

    /* allocate space for the sprintf'd command we'll pass to system() */
    grow_command_buf( strlen(cc_command) + strlen(cc_flags) + 200 );

    /* Compile the source.
     * Unfortunately there's no completely portable way to redirect stderr
     * yet be able to recover it later, so we're stuck seeing the
     * errors when something fails.
     */
    if (charm_run_available && verbosity < 2) {
        sprintf(command_buf, "%s_charm_run %s %s %s%s %s. %s", 
            local_command_start, cc_command, source_path, object_flag, 
            object_path, include_flag, cc_flags);
    }
    else {
        sprintf(command_buf, "%s %s %s%s %s. %s", cc_command, source_path, 
            object_flag, object_path, include_flag, cc_flags);
    }
    system(command_buf);

    /* see if compilation was successful */
    garbage_fh = fopen(object_path, "r");
    successful = garbage_fh != NULL;
    if (garbage_fh != NULL && fclose(garbage_fh)) 
        die("Error closing file '%s': %s", object_path, strerror(errno));

    return successful;
}

static void
clean_up_try()
{
    remove(TRY_SOURCE_PATH);
    remove(TRY_APP_PATH);
    remove(TARGET_PATH);
}

void
shorten_constant(FILE *conf_fh, const char *symbol)
{
    fprintf(conf_fh, "# define %s %s%s\n", symbol, constant_prefix, symbol); 
}

void
shorten_macro(FILE *conf_fh, const char *symbol)
{
    fprintf(conf_fh, "# define %s %s%s\n", symbol, macro_prefix, symbol); 
}

void
shorten_typedef(FILE *conf_fh, const char *symbol)
{
    fprintf(conf_fh, "# define %s %s%s\n", symbol, typedef_prefix, symbol); 
}

void
shorten_function(FILE *conf_fh, const char *symbol)
{
    fprintf(conf_fh, "# define %s %s%s\n", symbol, function_prefix, symbol); 
}

void
write_file(const char *filename, const char *content, size_t content_len)
{
    FILE *fh = fopen(filename, "w+");
    if (fh == NULL)
        die("Couldn't open '%s': %s", filename, strerror(errno));
    fwrite(content, sizeof(char), content_len, fh);
    if (fclose(fh))
        die("Error when closing '%s': %s", filename, strerror(errno));
}

char*
slurp_file(char *file_path, size_t *len_ptr) 
{
    FILE   *const file = fopen(file_path, "r");
    char   *contents;
    size_t  len;
    long    check_val;

    /* sanity check */
    if (file == NULL)
        die("Error opening file '%s': %s", file_path, strerror(errno));

    /* find length; return NULL if the file has a zero-length */
    len = flength(file);
    if (len == 0) {
        *len_ptr = 0;
        return NULL;
    }

    /* allocate memory and read the file */
    contents = (char*)malloc(len * sizeof(char) + 1);
    if (contents == NULL)
        die("Out of memory at %d, %s", __FILE__, __LINE__);
    contents[len] = '\0';
    check_val = fread(contents, sizeof(char), len, file);

    /* weak error check, because CRLF might result in fewer chars read */
    if (check_val <= 0)
        die("Tried to read %d characters of '%s', got %d", (int)len,
            file_path, check_val);

    /* set length pointer for benefit of caller */
    *len_ptr = check_val;

    /* clean up */
    if (fclose(file))
        die("Error closing file '%s': %s", file_path, strerror(errno));

    return contents;
}

long 
flength(FILE *f) 
{
    const long bookmark = ftell(f);
    long check_val;
    long len;

    /* seek to end of file and check length */
    check_val = fseek(f, 0, SEEK_END);
    if (check_val == -1)
        die("fseek error : %s\n", strerror(errno));
    len = ftell(f);
    if (len == -1)
        die("ftell error : %s\n", strerror(errno));

    /* return to where we were */
    check_val = fseek(f, bookmark, SEEK_SET);
    if (check_val == -1)
        die("fseek error : %s\n", strerror(errno));

    return len;
}

void 
die(char* format, ...) 
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
    exit(1);
}

void 
warn(char* format, ...) 
{
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
    fprintf(stderr, "\n");
}

int
remove_and_verify(char *file_path) 
{
    /* try to remove the file */
    remove(file_path);

    /* return what *might* be success or failure */
    return can_open_file(file_path) ? 0 : 1;
}

int
can_open_file(char *file_path) 
{
    FILE *garbage_fh;

    /* use fopen as a portable test for the existence of a file */
    garbage_fh = fopen(file_path, "r");
    if (garbage_fh == NULL) {
        return 0;
    }
    else {
        fclose(garbage_fh);
        return 1;
    }
}

/**
 * Copyright 2006 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

