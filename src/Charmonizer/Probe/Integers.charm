#define CHAZ_USE_SHORT_NAMES

#include "Charmonizer/Core/ModHandler.h"
#include "Charmonizer/Core/Util.h"
#include "Charmonizer/Probe/Integers.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

/* Determine endian-ness of this machine.
 */
static chaz_bool_t
machine_is_big_endian();

static char sizes_code[] = METAQUOTE
    #include "_charm.h"
    int main () {
        Charm_Setup;
        printf("%d %d %d %d %d",
            (int)sizeof(char),
            (int)sizeof(short),
            (int)sizeof(int),
            (int)sizeof(long),
            (int)sizeof(void *)
        );
        return 0;
    }
METAQUOTE;

static char inttypes_code[] = METAQUOTE
    #include "_charm.h"
    #include <inttypes.h>
    int main()
    {
        Charm_Setup;
        printf("We have inttypes.h\n");
        return 0;
    }
METAQUOTE;

static char long_long_code[] = METAQUOTE
    #include "_charm.h"
    int main() 
    {
        Charm_Setup;
        printf("%d", (int)sizeof(long long));
        return 0;
    }
METAQUOTE;

static char __int64_code[] = METAQUOTE
    #include "_charm.h"
    int main() 
    {
        Charm_Setup;
        printf("%d", (int)sizeof(__int64));
        return 0;
    }
METAQUOTE;

void
chaz_Integers_run(void) 
{
    char *output;
    size_t output_len;
    int sizeof_char       = -1; 
    int sizeof_short      = -1; 
    int sizeof_int        = -1; 
    int sizeof_ptr        = -1; 
    int sizeof_long       = -1;
    int sizeof_long_long  = -1;
    int sizeof___int64    = -1;
    chaz_bool_t has_8     = false;
    chaz_bool_t has_16    = false;
    chaz_bool_t has_32    = false;
    chaz_bool_t has_64    = false;
    chaz_bool_t has_long_long = false;
    chaz_bool_t has___int64   = false;
    chaz_bool_t has_inttypes  = false;
    char i32_t_type[10];
    char i32_t_postfix[10];
    char u32_t_postfix[10];
    char i64_t_type[10];
    char i64_t_postfix[10];
    char u64_t_postfix[10];

    START_RUN("Integers");

    /* document endian-ness */
    if (machine_is_big_endian())
        append_conf("#define %sBIG_END\n", constant_prefix);
    else 
        append_conf("#define %sLITTLE_END\n", constant_prefix);

    /* Record sizeof() for several common integer types. */
    output = capture_output(sizes_code, strlen(sizes_code), &output_len);
    if (output != NULL) {
        char *end_ptr = output;
        
        sizeof_char  = strtol(output, &end_ptr, 10);
        output       = end_ptr;
        sizeof_short = strtol(output, &end_ptr, 10);
        output       = end_ptr;
        sizeof_int   = strtol(output, &end_ptr, 10);
        output       = end_ptr;
        sizeof_long  = strtol(output, &end_ptr, 10);
        output       = end_ptr;
        sizeof_ptr   = strtol(output, &end_ptr, 10);
    }

    /* determine whether long longs are available */
    output = capture_output(long_long_code, strlen(long_long_code),
        &output_len);
    if (output != NULL) {
        has_long_long    = true;
        sizeof_long_long = strtol(output, NULL, 10);
    }

    /* determine whether the __int64 type is available */
    output = capture_output(__int64_code, strlen(__int64_code),
        &output_len);
    if (output != NULL) {
        has___int64 = true;
        sizeof___int64 = strtol(output, NULL, 10);
    }

    /* determine whether inttypes.h is available */
    output = capture_output(inttypes_code, strlen(inttypes_code),
        &output_len);
    if (output != NULL) {
        has_inttypes = true;
    }

    /* figure out which integer types are available */
    if (sizeof_char == 1) {
        has_8 = true;
    }
    if (sizeof_short == 2) {
        has_16 = true;
    }
    if (sizeof_int == 4) {
        has_32 = true;
        strcpy(i32_t_type, "int");
        strcpy(i32_t_postfix, "");
        strcpy(u32_t_postfix, "U");
    }
    else if (sizeof_long == 4) {
        has_32 = true;
        strcpy(i32_t_type, "long");
        strcpy(i32_t_postfix, "L");
        strcpy(u32_t_postfix, "UL");
    }
    if (sizeof_long == 8) {
        has_64 = true;
        strcpy(i64_t_type, "long");
        strcpy(i64_t_postfix, "L");
        strcpy(u64_t_postfix, "UL");
    }
    else if (sizeof_long_long == 8) {
        has_64 = true;
        strcpy(i64_t_type, "long long");
        strcpy(i64_t_postfix, "LL");
        strcpy(u64_t_postfix, "LLU");
    }
    else if (sizeof___int64 == 8) {
        has_64 = true;
        strcpy(i64_t_type, "__int64");
        strcpy(i64_t_postfix, "i64");
        strcpy(u64_t_postfix, "ui64");
    }

    /* write out some conditional defines */
    if (has_inttypes)
        append_conf("#define %sHAS_INTTYPES_H\n", constant_prefix);
    if (has_long_long)
        append_conf("#define %sHAS_LONG_LONG\n", constant_prefix);
    if (has___int64)
        append_conf("#define %sHAS___INT64\n", constant_prefix);

    /* write out sizes */
    append_conf(
        "#define %sSIZEOF_CHAR %d\n"
        "#define %sSIZEOF_SHORT %d\n"
        "#define %sSIZEOF_INT %d\n"
        "#define %sSIZEOF_LONG %d\n"
        "#define %sSIZEOF_PTR %d\n",
        constant_prefix, sizeof_char,
        constant_prefix, sizeof_short,
        constant_prefix, sizeof_int,
        constant_prefix, sizeof_long,
        constant_prefix, sizeof_ptr
    );
    if (has_long_long) {
        append_conf("#define %sSIZEOF_LONG_LONG %d\n",
            constant_prefix, sizeof_long_long);
    }
    if (has___int64) {
        append_conf("#define %sSIZEOF___INT64 %d\n",
            constant_prefix, sizeof___int64);
    }

    /* write affirmations, typedefs and maximums/minimums */
    append_conf("typedef int %sbool_t;\n", typedef_prefix);
    if (has_8) {
        append_conf(
            "#define %sHAS_I8_T\n"
            "typedef char %si8_t;\n"
            "typedef unsigned char %su8_t;\n",
            constant_prefix, typedef_prefix, typedef_prefix
        );
        append_conf(
            "#define %sI8_MAX 0x7F\n"
            "#define %sI8_MIN (-I8_MAX - 1)\n"
            "#define %sU8_MAX (I8_MAX * 2 + 1)\n",
            constant_prefix, constant_prefix, constant_prefix
        );
    }
    if (has_16) {
        append_conf(
            "#define %sHAS_I16_T\n"
            "typedef short %si16_t;\n"
            "typedef unsigned short %su16_t;\n",
            constant_prefix, typedef_prefix, typedef_prefix
        );
        append_conf(
            "#define %sI16_MAX 0x7FFF\n"
            "#define %sI16_MIN (-I16_MAX - 1)\n"
            "#define %sU16_MAX (I16_MAX * 2 + 1)\n",
            constant_prefix, constant_prefix, constant_prefix
        );
    }
    if (has_32) {
        append_conf(
            "#define %sHAS_I32_T\n"
            "typedef %s %si32_t;\n"
            "typedef unsigned %s %su32_t;\n",
            constant_prefix,
            i32_t_type, typedef_prefix, 
            i32_t_type, typedef_prefix
        );
        append_conf(
            "#define %sI32_MAX 0x7FFFFFFF%s\n"
            "#define %sI32_MIN (-I32_MAX - 1)\n"
            "#define %sU32_MAX (I32_MAX * 2%s + 1%s)\n",
            constant_prefix, i32_t_postfix,
            constant_prefix, 
            constant_prefix, u32_t_postfix, u32_t_postfix
        );
    }
    if (has_64) {
        append_conf(
            "#define %sHAS_I64_T\n"
            "typedef %s %si64_t;\n"
            "typedef unsigned %s %su64_t;\n",
            constant_prefix,
            i64_t_type, typedef_prefix, 
            i64_t_type, typedef_prefix
        );
        append_conf(
            "#define %sI64_MAX 0x7FFFFFFFFFFFFFFF%s\n"
            "#define %sI64_MIN (-I64_MAX - 1%s)\n"
            "#define %sU64_MAX (I64_MAX * 2%s + 1%s)\n",
            constant_prefix, i64_t_postfix,
            constant_prefix, i64_t_postfix,
            constant_prefix, u64_t_postfix, u64_t_postfix
        );
    }

    /* create the I64P and U64P printf macros */
    if (has_64) {
        int i;
        char *options[] = {
            "ll",
            "l",
            "L",
            "q",  /* Some *BSDs */
            "I64", /* Microsoft */
            NULL,
        };

        /* buffer to hold the code, and its start and end */
        char format_64_code[1000];
        static char format_64_code_a[] = METAQUOTE
            #include "_charm.h"
            int main() {
                Charm_Setup;
                printf(
        METAQUOTE;
        static char format_64_code_b[] = METAQUOTE
                );
                return 0;
            }
        METAQUOTE;

        for (i = 0; options[i] != NULL; i++) {
            /* try to print 2**64-1, and see if we get it back intact */
            sprintf(format_64_code, 
                "%s\"%%%su\", 18446744073709551615%s%s", format_64_code_a, 
                    options[i], u64_t_postfix, format_64_code_b);
            output = capture_output(format_64_code, strlen(format_64_code),
                &output_len);

            if (   output_len != 0 
                && strcmp(output, "18446744073709551615") == 0
            ) {
                append_conf(
                    "#define %sI64P \"%sd\"\n"
                    "#define %sU64P \"%su\"\n",
                    macro_prefix, options[i], 
                    macro_prefix, options[i]
                );
                break;
            }
        }

    }

    /* write out the 32-bit and 64-bit literal macros */
    if (has_32) {
        if (strcmp(i32_t_postfix, "") == 0) {
            append_conf(
                "#define %sI32_C(n) n\n"
                "#define %sU32_C(n) n##%s\n",
                macro_prefix, 
                macro_prefix, u32_t_postfix
            );
        }
        else {
            append_conf(
                "#define %sI32_C(n) n##%s\n"
                "#define %sU32_C(n) n##%s\n",
                macro_prefix, i32_t_postfix,
                macro_prefix, u32_t_postfix
            );
        }
    }
    if (has_64) {
        append_conf(
            "#define %sI64_C(n) n##%s\n"
            "#define %sU64_C(n) n##%s\n",
            macro_prefix, i64_t_postfix,
            macro_prefix, u64_t_postfix
        );
    }

    /* true and false */
    append_conf(
        "#ifndef true\n"
        "# define true 1\n"
        "#endif\n"
        "#ifndef false\n"
        "# define false 0\n"
        "#endif\n"
    );

    if (want_short_names) {
        START_SHORT_NAMES;

        if (machine_is_big_endian())
            shorten_constant("BIG_END");
        else 
            shorten_constant("LITTLE_END");

        shorten_constant("SIZEOF_CHAR");
        shorten_constant("SIZEOF_SHORT");
        shorten_constant("SIZEOF_LONG");
        shorten_constant("SIZEOF_INT");
        shorten_constant("SIZEOF_PTR");

        if (has_long_long) {
            shorten_constant("HAS_LONG_LONG");
            shorten_constant("SIZEOF_LONG_LONG");
        }
        if (has___int64) {
            shorten_constant("HAS___INT64");
            shorten_constant("SIZEOF___INT64");
        }

        if (has_inttypes)
            shorten_constant("HAS_INTTYPES_H");

        shorten_typedef("bool_t");

        if (has_8) {
            shorten_constant("HAS_I8_T");
            shorten_typedef("i8_t");
            shorten_typedef("u8_t");
            shorten_constant("I8_MAX");
            shorten_constant("I8_MIN");
            shorten_constant("U8_MAX");
        }
        if (has_16) {
            shorten_constant("HAS_I16_T");
            shorten_typedef("i16_t");
            shorten_typedef("u16_t");
            shorten_constant("I16_MAX");
            shorten_constant("I16_MIN");
            shorten_constant("U16_MAX");
        }
        if (has_32) {
            shorten_constant("HAS_I32_T");
            shorten_typedef("i32_t");
            shorten_typedef("u32_t");
            shorten_constant("I32_MAX");
            shorten_constant("I32_MIN");
            shorten_constant("U32_MAX");
            shorten_macro("I32_C");
            shorten_macro("U32_C");
        }

        if (has_64) {
            shorten_constant("HAS_I64_T");
            shorten_typedef("i64_t");
            shorten_typedef("u64_t");
            shorten_constant("I64_MAX");
            shorten_constant("I64_MIN");
            shorten_constant("U64_MAX");
            shorten_macro("I64P");
            shorten_macro("U64P");
            shorten_macro("I64_C");
            shorten_macro("U64_C");
        } 

        END_SHORT_NAMES;
    }
    
    END_RUN;
}

static chaz_bool_t
machine_is_big_endian()
{
    long one = 1;
    return !(*((char *)(&one)));
}

/**
 * Copyright 2006 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

