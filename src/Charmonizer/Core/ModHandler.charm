#define CHAZ_USE_SHORT_NAMES

#include "Charmonizer/Core/Util.h"
#include "Charmonizer/Core/ModHandler.h"
#include "Charmonizer/Core/OperSys.h"
#include "Charmonizer/Core/Compiler.h"
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>


/* Write the "_charm.h" file used by every probe.
 */
static void
write_charm_h();

/* Compile a small wrapper application which is used to redirect error output
 * to devnull.
 */
static void
build_charm_run();

/* Clean up the files associated with capture_output().
 */
static void
clean_up_try();

struct chaz_OperSys  *chaz_ModHand_os = NULL;
struct chaz_Compiler *chaz_ModHand_compiler = NULL;
chaz_bool_t chaz_ModHand_charm_run_available = false;
FILE* chaz_ModHand_charm_test_h_fh = NULL;
chaz_bool_t chaz_ModHand_want_charm_test_h = false;

char *constant_prefix = NULL;
char *macro_prefix    = NULL;
char *typedef_prefix  = NULL;
char *function_prefix = NULL;

chaz_bool_t want_short_names = false;


static char *try_app_path = NULL;
static char *try_app_command = NULL;

void
chaz_ModHand_init()
{
    size_t len;

    /* set the name of the application which we "try" to execute */
    len = strlen(TRY_APP_BASENAME) + strlen(os->exe_ext) + 1;
    try_app_path = (char*)malloc(len);
    sprintf(try_app_path, "%s%s", TRY_APP_BASENAME, os->exe_ext);

    /* set the invocation string for the "try" application */
    len += strlen(os->local_command_start);
    try_app_command = (char*)malloc(len);
    sprintf(try_app_command, "%s%s", os->local_command_start, try_app_path);

    /* write files needed by this module and others */
    build_charm_run();
    write_charm_h();
}

static char charm_h_code[] = METAQUOTE
    #ifndef CHARM_H
    #define CHARM_H 1

    #include <stdio.h>

    #define Charm_Setup \
        freopen("_charmonizer_target", "w", stdout)
    
    #endif
METAQUOTE;

static void
write_charm_h()
{
    write_file("_charm.h", charm_h_code, strlen(charm_h_code));
}

static char charm_run_code_a[] = METAQUOTE
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stddef.h>
    int main(int argc, char **argv)
    {
        char *command;
        size_t command_len = 1; /* terminating null */
        int i;
        
        /* rebuild the command line args, minus the name of this utility */
        for (i = 1; i < argc; i++) {
            command_len += strlen(argv[i]) + 1;
        }
        command = (char*)calloc(command_len, sizeof(char));
        for (i = 1; i < argc; i++) {
            strcat( strcat(command, " "), argv[i] );
        }

        /* redirect stderr to /dev/null or equivalent */
        freopen( 
METAQUOTE;

static char charm_run_code_b[] = METAQUOTE
             , "w", stderr);

        /* run the commmand and return its value to the parent process */
        return system(command);
    }
METAQUOTE;

static void
build_charm_run()
{
    size_t code_len = strlen(charm_run_code_a) + strlen(charm_run_code_b) +
        strlen(os->devnull) + 20;
    char *code = (char*)malloc(code_len);
    chaz_bool_t compile_succeeded = false;

    sprintf(code, "%s \"%s\" %s", charm_run_code_a, os->devnull,
        charm_run_code_b);

    compile_succeeded = compiler->compile_exe(compiler, "_charm_run.c", 
        "_charm_run", code, strlen(code));
    if (!compile_succeeded)
        die("failed to compile _charm_run helper utility");

    remove("_charm_run.c");
    charm_run_available = true;
}

char*
chaz_ModHand_capture_output(char *source, size_t source_len, 
                            size_t *output_len) 
{
    char *captured_output = NULL;
    chaz_bool_t compile_succeeded;

    /* clear out previous versions and test to make sure removal worked */
    if ( !remove_and_verify(try_app_path) ) 
        die("Failed to delete file '%s'", try_app_path);
    if ( !remove_and_verify(TARGET_PATH) )
        die("Failed to delete file '%s'", TARGET_PATH);

    compile_succeeded = compiler->compile_exe(compiler, TRY_SOURCE_PATH, 
        try_app_path, source, source_len);

    if (compile_succeeded) {
        /* run the app, slurp the output */
        system(try_app_command);
        captured_output = slurp_file(TARGET_PATH, output_len);
    }
    else {
        *output_len = 0;
    }

    clean_up_try();

    return captured_output;
}

void
chaz_ModHand_append_conf(FILE *conf_fh, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(conf_fh, fmt, args);
    va_end(args);

    if (want_charm_test_h) {
        va_start(args, fmt);
        vfprintf(charm_test_h_fh, fmt, args);
        va_end(args);
    }
}

static void
clean_up_try()
{
    remove(TRY_SOURCE_PATH);
    remove(try_app_path);
    remove(TARGET_PATH);
}

void
chaz_ModHand_shorten_constant(FILE *conf_fh, const char *sym)
{
    append_conf(conf_fh, "# define %s %s%s\n", sym, constant_prefix, sym); 
}

void
chaz_ModHand_shorten_macro(FILE *conf_fh, const char *sym)
{
    append_conf(conf_fh, "# define %s %s%s\n", sym, macro_prefix, sym); 
}

void
chaz_ModHand_shorten_typedef(FILE *conf_fh, const char *sym)
{
    append_conf(conf_fh, "# define %s %s%s\n", sym, typedef_prefix, sym); 
}

void
chaz_ModHand_shorten_function(FILE *conf_fh, const char *sym)
{
    append_conf(conf_fh, "# define %s %s%s\n", sym, function_prefix, sym); 
}

void
chaz_ModHand_write_charm_test_h()
{
    charm_test_h_fh = fopen("_charm_test.h", "w+");
    if (charm_test_h_fh == NULL)
        die("Couldn't open '_charm_test.h': %s", strerror(errno));

    fprintf(charm_test_h_fh, "#define %sUSE_SHORT_NAMES\n", constant_prefix);

    want_charm_test_h = true;
}


/**
 * Copyright 2006 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

