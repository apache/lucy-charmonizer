#define CHAZ_USE_SHORT_NAMES

#include "Charmonizer/Core/Util.h"
#include "Charmonizer/Core/ConfWriter.h"
#include "Charmonizer/Core/OperatingSystem.h"
#include "Charmonizer/Core/Compiler.h"
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>


/* Write the "_charm.h" file used by every probe.
 */
static void
S_write_charm_h();

/* Compile a small wrapper application which is used to redirect error output
 * to dev_null.
 */
static void
S_build_charm_run();

/* Clean up the files associated with capture_output().
 */
static void
S_clean_up_try();

/* Global vars. */
chaz_bool_t chaz_ConfWriter_charm_run_available = false;
FILE* ConfWriter_charmony_fh = NULL;

/* Static vars. */
static char *try_app_name = NULL;

void
ConfWriter_init()
{
    /* Set the name of the application which we "try" to execute. */
    const char *exe_ext = OS_exe_ext();
    size_t len = strlen(TRY_APP_BASENAME) + strlen(exe_ext) + 1;
    try_app_name = (char*)malloc(len);
    sprintf(try_app_name, "%s%s", TRY_APP_BASENAME, exe_ext);

    /* Write files needed by this module and others. */
    S_build_charm_run();
    S_write_charm_h();
}

void
ConfWriter_open_charmony_h(const char *charmony_start)
{
    /* Open the filehandle. */
    ConfWriter_charmony_fh = fopen("charmony.h", "w+");
    if (ConfWriter_charmony_fh == NULL) {
        Util_die("Can't open 'charmony.h': %s", strerror(errno));
    }

    /* Print supplied text (if any) along with warning, open include guard. */
    if (charmony_start != NULL) {
        fprintf(ConfWriter_charmony_fh, charmony_start);
    }
    fprintf(ConfWriter_charmony_fh,
        "/* Header file auto-generated by Charmonizer. \n"
        " * DO NOT EDIT THIS FILE!!\n"
        " */\n\n"
        "#ifndef H_CHARMONY\n"
        "#define H_CHARMONY 1\n\n"
    );
}

void
ConfWriter_clean_up(void)
{
    /* Clean up some temp files. */
    remove("_charm.h");
    OS_remove_exe("_charm_run");
    OS_remove_exe("_charm_stat");

    /* Write the last bit of charmony.h and close. */
    fprintf(ConfWriter_charmony_fh, "#endif /* H_CHARMONY */\n\n");
    if (fclose(ConfWriter_charmony_fh)) {
        Util_die("Couldn't close 'charmony.h': %s", strerror(errno));
    }
}

static char charm_h_code[] = METAQUOTE
    #ifndef CHARM_H
    #define CHARM_H 1

    #include <stdio.h>

    #define Charm_Setup \
        freopen("_charmonizer_target", "w", stdout)
    
    #endif
METAQUOTE;

static void
S_write_charm_h()
{
    Util_write_file("_charm.h", charm_h_code);
}

static char charm_run_code_a[] = METAQUOTE
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stddef.h>
    int main(int argc, char **argv)
    {
        char *command;
        size_t command_len = 1; /* Terminating null. */
        int i;
        int retval;
        
        /* Rebuild the command line args, minus the name of this utility. */
        for (i = 1; i < argc; i++) {
            command_len += strlen(argv[i]) + 1;
        }
        command = (char*)calloc(command_len, sizeof(char));
METAQUOTE;

static char charm_run_code_b[] = METAQUOTE
        if (command == NULL) {
            fprintf(stderr, "calloc failed\n");
            exit(1);
        }
        for (i = 1; i < argc; i++) {
            strcat( strcat(command, " "), argv[i] );
        }

        /* Redirect stdout and stderr to /dev/null or equivalent. */
        freopen( 
METAQUOTE;

static char charm_run_code_c[] = METAQUOTE
             , "w", stdout);
        freopen( 
METAQUOTE;

static char charm_run_code_d[] = METAQUOTE
             , "w", stderr);

        /* Run the commmand and return its value to the parent process. */
        retval = system(command);
        free(command);
        return retval;
    }
METAQUOTE;

static void
S_build_charm_run()
{
    chaz_bool_t compile_succeeded = false;
    const char *dev_null = OS_dev_null();
    size_t needed = sizeof(charm_run_code_a)
                  + sizeof(charm_run_code_b)
                  + strlen(dev_null)
                  + sizeof(charm_run_code_c)
                  + strlen(dev_null)
                  + sizeof(charm_run_code_d)
                  + 20;
    char *code = (char*)malloc(needed);

    sprintf(code, "%s%s \"%s\" %s \"%s\" %s", 
        charm_run_code_a, 
        charm_run_code_b,
        dev_null,
        charm_run_code_c,
        dev_null,
        charm_run_code_d);
    compile_succeeded = CC_compile_exe("_charm_run.c", "_charm_run", 
        code, strlen(code));
    if (!compile_succeeded) {
        Util_die("failed to compile _charm_run helper utility");
    }

    remove("_charm_run.c");
    free(code);
    chaz_ConfWriter_charm_run_available = true;
}

chaz_bool_t
ConfWriter_test_compile(char *source, size_t source_len)
{
    chaz_bool_t compile_succeeded;

    if ( !Util_remove_and_verify(try_app_name) ) {
        Util_die("Failed to delete file '%s'", try_app_name);
    }

    compile_succeeded = CC_compile_exe(TRY_SOURCE_PATH, TRY_APP_BASENAME,
        source, source_len);

    S_clean_up_try();

    return compile_succeeded;
}

char*
ConfWriter_capture_output(char *source, size_t source_len, 
                            size_t *output_len) 
{
    char *captured_output = NULL;
    chaz_bool_t compile_succeeded;

    /* Clear out previous versions and test to make sure removal worked. */
    if ( !Util_remove_and_verify(try_app_name) ) {
        Util_die("Failed to delete file '%s'", try_app_name);
    }
    if ( !Util_remove_and_verify(TARGET_PATH) ) {
        Util_die("Failed to delete file '%s'", TARGET_PATH);
    }

    /* Attempt compilation; if successful, run app and slurp output. */
    compile_succeeded = CC_compile_exe(TRY_SOURCE_PATH, TRY_APP_BASENAME, 
        source, source_len);
    if (compile_succeeded) {
        OS_run_local(try_app_name, NULL);
        captured_output = Util_slurp_file(TARGET_PATH, output_len);
    }
    else {
        *output_len = 0;
    }

    /* Remove all the files we just created. */
    S_clean_up_try();

    return captured_output;
}

void
ConfWriter_append_conf(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(ConfWriter_charmony_fh, fmt, args);
    va_end(args);
}

static void
S_clean_up_try()
{
    remove(TRY_SOURCE_PATH);
    OS_remove_exe(TRY_APP_BASENAME);
    remove(TARGET_PATH);
}

void
ConfWriter_shorten_macro(const char *sym)
{
    ConfWriter_append_conf("  #define %s CHY_%s\n", sym, sym); 
}

void
ConfWriter_shorten_typedef(const char *sym)
{
    ConfWriter_append_conf("  #define %s chy_%s\n", sym, sym); 
}

void
ConfWriter_shorten_function(const char *sym)
{
    ConfWriter_append_conf("  #define %s chy_%s\n", sym, sym); 
}


/**
 * Copyright 2006 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

